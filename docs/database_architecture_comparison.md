# مقایسهٔ معماری دیتابیس با CMMS تجاری (SQL Server)

## هدف
مقایسهٔ ساختار دیتابیس Supabase/PostgreSQL پروژه با یک دیتابیس CMMS تجاری روی SQL Server و پیشنهاد بهبودها.

---

## وضعیت فعلی دیتابیس ما (خلاصه)

- **جداول:** تعداد زیاد جدول برای نت، تولید، انبار، HSE، گزارش‌های شیفت، دستور کار، PM، پروژه، پرسنل، تجهیزات و غیره؛ بیشتر با `id` (UUID) به‌عنوان PK و FKهای مشخص.
- **ستون‌ها:** ترکیبی از فیلدهای ثابت و `jsonb` برای دادهٔ داینامیک (مثلاً `full_data`, `payload`, `labor_details`, `used_parts`).
- **کلیدهای اصلی و خارجی:** تعریف شده و یکپارچگی ارجاعی رعایت شده است.
- **ایندکس‌ها:** محدود؛ عمدتاً روی `created_at`, `sort_order`, چند FK و یک ایندکس روی `parts(name)`. روی بسیاری از ستون‌های جستجو/فیلتر (مثل `status`, `tracking_code`, `report_date`) ایندکس صریح نداریم.
- **View:** در حال حاضر **هیچ View** در دیتابیس تعریف نشده؛ گزارش‌ها و لیست‌ها معمولاً در اپ با کوئری مستقیم یا از طریق گزارش‌ساز داینامیک ساخته می‌شوند.
- **توابع:** چند تابع (مثل `get_next_tracking_code`, `get_next_shift_code_from_prefix`, `bump_announcement_version`) و توابع کمکی برای گزارش (مثل `list_public_tables`, `exec_read_only_query`).
- **تریگر:** فقط یک تریگر برای به‌روزرسانی `announcement_version` در `app_settings`.

---

## تفاوت‌های معمول با CMMS تجاری (SQL Server)

در اسکیمای CMMSهای تجاری معمولاً این موارد دیده می‌شود:

1. **جدول‌های Lookup و نرمال‌سازی:** وضعیت‌ها، نوع کار، اولویت، واحد و غیره در جدول‌های جدا (مثلاً `WorkOrderStatus`, `Priority`, `Unit`) با FK به‌جای متن آزاد در هر جدول.
2. **ایندکس‌های هدفمند:** ایندکس روی هر FK، روی ستون‌های فیلتر/جستجو/مرتب‌سازی و گاهی ایندکس ترکیبی برای کوئری‌های پرتکرار.
3. **Viewهای آماده:** View برای داشبوردها، گزارش‌های تکراری، JOINهای پیچیده و خلاصه‌ی KPI تا هم کوئری ساده‌تر شود هم یک لایهٔ انتزاع برای اپ.
4. **Stored Procedure / Function:** منطق کسب‌وکار (مثلاً شماره‌گذاری، تأیید گردش کار، محاسبهٔ هزینه) در دیتابیس متمرکز شده است.
5. **تریگر و قوانین یکپارچگی:** برای audit، به‌روزرسانی خودکار فیلدها یا اعتبارسنجی.
6. **جدول‌های پشتیبانی:** جداول جدا برای تاریخ، شیفت، واحد اندازه‌گیری و غیره با روابط روشن.

دیتابیس ما از نظر **ساختار جدول‌ها و FKها** برای یک اپ نت/تولید قابل قبول است، ولی از نظر **ایندکس، View و نرمال‌سازی وضعیت/کدها** نسبت به آن الگو ساده‌تر است و برای حجم و پیچیدگی بالاتر باید تقویت شود.

---

## نظر و پیشنهادها

- **ساده بودن به‌خودی‌خود بد نیست:** برای فاز اول و حجم متوسط، مدل فعلی قابل نگهداری است؛ مشکل اصلی وقتی است که داده و کوئری زیاد شود بدون ایندکس و بدون View.
- **اولویت ۱ – ایندکس:**  
  روی ستون‌هایی که در فیلتر، جستجو یا مرتب‌سازی استفاده می‌شوند ایندکس اضافه کنید، از جمله:  
  `work_orders(status, request_date)`, `shift_reports(shift_date, shift_name)`, `report_records(definition_id, report_date)`, `tracking_code` در جداولی که با کد جستجو می‌کنید، و همهٔ ستون‌های FK که در JOIN استفاده می‌شوند و ایندکس ندارند.
- **اولویت ۲ – View:**  
  برای داشبوردها و گزارش‌های ثابت (مثلاً خلاصهٔ دستور کار به‌تفکیک وضعیت، تولید روزانه، لیست تجهیزات با نام کلاس/گروه) View تعریف کنید تا کوئری در اپ ساده و یکسان شود و در آینده به‌راحتی قابل تغییر باشد.
- **اولویت ۳ – جدول Lookup (اختیاری):**  
  برای فیلدهایی مثل `status`, `work_type`, `priority` اگر مقدارها ثابت و محدود هستند، می‌توان جدول مرجع و FK تعریف کرد تا یکپارچگی و گزارش‌گیری بهتر شود؛ در غیر این صورت حداقل در اپ یک لیست ثابت استفاده شود.
- **مقایسهٔ عددی:**  
  با اجرای تابع `get_database_architecture_report()` و کوئری «خلاصهٔ سریع» در فایل migration می‌توانید تعداد جداول، ستون‌ها، PK، FK، ایندکس، View، توابع و تریگرها را ببینید و با خروجی مشابه از دیتابیس CMMS تجاری مقایسه کنید.

---

## نحوهٔ استفاده از گزارش معماری

1. در **Supabase → SQL Editor** محتوای فایل  
   `supabase/migrations/supabase_migration_database_architecture_report.sql`  
   را اجرا کنید تا تابع `get_database_architecture_report()` ساخته شود.
2. سپس این کوئری را اجرا کنید:
   ```sql
   SELECT * FROM public.get_database_architecture_report() ORDER BY section, sort_key;
   ```
3. خروجی را بر اساس `section` (Tables, Columns, PrimaryKeys, ForeignKeys, Indexes, Views, Functions, Triggers) و فیلد `details` (jsonb) با گزارش معماری دیتابیس CMMS مقایسه کنید.

برای یک عدد سریع (تعداد جداول، ستون‌ها، FK، ایندکس، View و …) می‌توانید کوئری «خلاصهٔ سریع» داخل کامنت همان فایل migration را اجرا کنید.
